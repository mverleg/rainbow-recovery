<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kaboom.js Template</title>
  <meta name="description" content="Minimal Kaboom.js template: just a game window in the browser with boilerplate and dependencies via CDN." />
  <style>
    /* Make the canvas fill the whole window */
    html, body {
      height: 100%;
      margin: 0;
      background: #eee; /* light gray fallback background while Kaboom initializes */
    }
    #game {
      display: block; /* remove inline gap */
      width: 100vw;
      height: 100vh;
    }
    /* Optional: hide overflow on mobile address bar changes */
    body { overflow: hidden; }
    /* Rainbow overlay */
    .rainbow-container {
      position: absolute;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
      width: min(90vw, 900px);
      height: calc(min(90vw, 900px) / 2);
      pointer-events: none; /* allow clicks to pass through except on the arches themselves */
      z-index: 9999;
    }
    .rainbow-arch {
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      border-top-left-radius: 9999px;
      border-top-right-radius: 9999px;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-style: solid;
      border-bottom: none;
      opacity: 0.55; /* vague by default */
      filter: saturate(70%) brightness(0.95);
      transition: opacity 200ms ease, filter 200ms ease, transform 200ms ease;
      pointer-events: auto; /* enable hover */
    }
    .rainbow-arch:hover {
      opacity: 1;
      filter: saturate(120%) brightness(1.15);
    }
    /* Define sizes and colors for each arch (red outermost) */
    .arch-red    { width: 100%;          height: 50%; border-width: 28px; border-color: #e53935; }
    .arch-orange { width: calc(100% - 56px); height: calc(50% - 28px); border-width: 26px; border-color: #fb8c00; }
    .arch-yellow { width: calc(100% - 56px - 52px); height: calc(50% - 28px - 26px); border-width: 24px; border-color: #fdd835; }
    .arch-green  { width: calc(100% - 56px - 52px - 48px); height: calc(50% - 28px - 26px - 24px); border-width: 22px; border-color: #43a047; }
    .arch-blue   { width: calc(100% - 56px - 52px - 48px - 44px); height: calc(50% - 28px - 26px - 24px - 22px); border-width: 20px; border-color: #1e88e5; }
    .arch-purple { width: calc(100% - 56px - 52px - 48px - 44px - 40px); height: calc(50% - 28px - 26px - 24px - 22px - 20px); border-width: 18px; border-color: #8e24aa; }

    /* Small screens tweak to reduce thickness */
    @media (max-width: 480px) {
      .arch-red    { border-width: 22px; }
      .arch-orange { border-width: 20px; }
      .arch-yellow { border-width: 18px; }
      .arch-green  { border-width: 16px; }
      .arch-blue   { border-width: 14px; }
      .arch-purple { border-width: 12px; }
    }
  </style>
</head>
<body>
  <!-- The canvas Kaboom will render to -->
  <canvas id="game"></canvas>

  <!-- Rainbow overlay on main menu (decorative; hover to brighten) -->
  <div class="rainbow-container" aria-hidden="true">
    <div class="rainbow-arch arch-red"    title="Red"></div>
    <div class="rainbow-arch arch-orange" title="Orange"></div>
    <div class="rainbow-arch arch-yellow" title="Yellow"></div>
    <div class="rainbow-arch arch-green"  title="Green"></div>
    <div class="rainbow-arch arch-blue"   title="Blue"></div>
    <div class="rainbow-arch arch-purple" title="Purple"></div>
  </div>

  <!-- Use Kaboom via CDN (ESM). Pin to a stable version to avoid breaking changes. -->
  <script src="https://unpkg.com/kaboom@3000.0.1/dist/kaboom.js"></script>
  <script type="module">
    // Initialize Kaboom. Using global: true exposes helpers like add(), sprite(), pos(), etc.
    const k = kaboom({
      canvas: document.querySelector('#game'),
      width: window.innerWidth,
      height: window.innerHeight,
      background: [ 230, 230, 230 ], // light gray background
      letterbox: true,
      global: true,
      // Set pixelDensity to 1 to keep a 1:1 mapping of CSS pixels to canvas pixels (optional)
      pixelDensity: 1,
    });

    // A global relayout callback that current scene can register
    let currentRelayout = null;

    // Grid overlay: draw a light grid across the canvas and keep it updated on resize
    let gridLines = [];

    function clearGrid() {
      for (const line of gridLines) {
        destroy(line);
      }
      gridLines = [];
    }

    // Use a 50% larger grid spacing everywhere (menu and levels)
    const GRID = 96;

    function buildGrid(spacing = GRID, lineW = 1, alpha = 0.6) {
      clearGrid();
      const w = width();
      const h = height();

      // Vertical lines (slightly bluish gray)
      for (let x = 0; x <= w; x += spacing) {
        const v = add([
          rect(lineW, h),
          anchor('topleft'),
          pos(x, 0),
          color(170, 180, 200),
          opacity(alpha),
          z(-1000),
        ]);
        gridLines.push(v);
      }

      // Horizontal lines (slightly reddish gray)
      for (let y = 0; y <= h; y += spacing) {
        const hLine = add([
          rect(w, lineW),
          anchor('topleft'),
          pos(0, y),
          color(200, 180, 180),
          opacity(alpha),
          z(-1000),
        ]);
        gridLines.push(hLine);
      }
    }

    // Keep canvas sized to the window on resize and rebuild the grid
    window.addEventListener('resize', () => {
      // Use global resize helper from Kaboom (k.resize may not exist)
      if (typeof resize === 'function') {
        resize(window.innerWidth, window.innerHeight);
      } else if (k && k.canvas) {
        // Fallback: manually resize the canvas element
        k.canvas.width = window.innerWidth;
        k.canvas.height = window.innerHeight;
      }
      // Rebuild grid in whatever current scene is active
      buildGrid();
      // Ask current scene (if any) to recompute layout/positions
      if (typeof currentRelayout === 'function') {
        currentRelayout();
      }
    });

    // Load all monster sprites from img/
    const monsters = [
      { key: 'red',    path: 'img/red-monster.png',    label: 'Red' },
      { key: 'orange', path: 'img/orange-monster.png', label: 'Orange' },
      { key: 'yellow', path: 'img/yellow-monster.png', label: 'Yellow' },
      { key: 'green',  path: 'img/green-monster.png',  label: 'Green' },
      { key: 'blue',   path: 'img/blue-monster.png',   label: 'Blue' },
      { key: 'purple', path: 'img/purple-monster.png', label: 'Purple' },
    ];

    for (const m of monsters) {
      loadSprite(m.key, m.path);
    }
    // Load player character sprites
    loadSprite('char-front', 'img/char-front.png');
    loadSprite('char-back', 'img/char-back.png');
    loadSprite('char-right', 'img/char-right.png');

    // Menu scene: shows all monsters; click or use arrows+Enter to select
    scene('menu', () => {
      const rainbow = document.querySelector('.rainbow-container');
      if (rainbow) rainbow.style.display = 'block';
      buildGrid();

      // Title
      const title = add([
        text('Choose a Monster', { size: 32 }),
        pos(width() / 2, 48),
        anchor('center'),
        color(0, 0, 0),
        z(10),
      ]);

      // Decorative player character (non-interactive) positioned under the rainbow
      function rainbowBottomY(offset = 24) {
        const el = document.querySelector('.rainbow-container');
        if (!el) return 110; // fallback if rainbow missing
        const rect = el.getBoundingClientRect();
        // rect.bottom is the pixel y from viewport top; Kaboom uses the same CSS pixel space
        return Math.min(height() - 10, Math.max(80, rect.bottom + offset));
      }

      const char = add([
        sprite('char-front'),
        anchor('center'),
        pos(width() / 2, rainbowBottomY()),
        z(5),
        opacity(0.95),
      ]);
      // Fit the character into a target max dimension (in pixels)
      const charTarget = 140; // make the player character larger on main page
      const charBase = Math.max(char.width, char.height);
      const charScale = charBase > 0 ? (charTarget / charBase) : 1;
      char.scale = vec2(charScale);

      const cols = 3;
      // Target maximum sprite size for uniform appearance (in pixels)
      const spriteMax = 150;
      // Cell padding should be large enough to accommodate enlarged selection (1.2x)
      const paddingX = spriteMax + 100;
      const paddingY = spriteMax + 100;
      const startX = width() / 2 - ((cols - 1) * paddingX) / 2;
      const startY = height() / 2 - paddingY / 2;

      const items = []; const labels = [];

      monsters.forEach((m, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = startX + col * paddingX;
        const y = startY + row * paddingY;

        const item = add([
          sprite(m.key),
          anchor('center'),
          pos(x, y),
          scale(1),
          area({ cursor: 'pointer' }),
          { monsterKey: m.key, monsterLabel: m.label, baseScale: 1 },
        ]);

        // Compute a uniform base scale so the sprite fits within spriteMax box
        const w = item.width;
        const h = item.height;
        const sRaw = Math.min(spriteMax / Math.max(1, w), spriteMax / Math.max(1, h));
        // Slightly increase red monster size for better prominence
        const s = m.key === 'red' ? sRaw * 1.1 : sRaw;
        item.baseScale = s;
        item.scale = vec2(s);

        // Label under sprite, positioned based on spriteMax to keep spacing consistent
        const label = add([
          text(m.label, { size: 18 }),
          anchor('top'),
          pos(x, y + spriteMax / 2 + 24),
          color(20, 20, 20),
        ]);
        labels.push(label);
        item.menuLabel = label;

        item.onClick(() => {
          go('level', m.key);
        });

        // Hover visual: slight scale-up and full opacity when hovered
        item.onUpdate(() => {
          const hovered = typeof item.isHovering === 'function' ? item.isHovering() : (typeof item.isHovered === 'function' ? item.isHovered() : false);
          const isSelected = (i === selected);
          let mult = isSelected ? 1.2 : 1;
          if (hovered) mult = Math.max(mult, 1.1);
          item.scale = vec2(item.baseScale * mult);
          item.opacity = (isSelected || hovered) ? 1 : 0.9;
        });

        items.push(item);
      });

      let selected = -1;

      function updateSelection() {
        // Selection visuals handled per-item in onUpdate combining selection and hover states.
        // This function remains to keep keyboard navigation logic intact.
      }

      function clampIndex(i) {
        const n = items.length;
        return (i + n) % n;
      }

      function moveHorizontal(dir) {
        selected = clampIndex(selected + dir);
        updateSelection();
      }

      function moveVertical(dir) {
        const n = items.length;
        const cols = 3;
        const rows = Math.ceil(n / cols);
        const curCol = selected % cols;
        const curRow = Math.floor(selected / cols);
        let newRow = curRow + dir;
        if (newRow < 0) newRow = rows - 1;
        if (newRow >= rows) newRow = 0;
        let newIndex = newRow * cols + curCol;
        // If last row is shorter, clamp to last item
        if (newIndex >= n) newIndex = n - 1;
        selected = newIndex;
        updateSelection();
      }

      onKeyPress('left', () => moveHorizontal(-1));
      onKeyPress('right', () => moveHorizontal(1));
      onKeyPress('up', () => moveVertical(-1));
      onKeyPress('down', () => moveVertical(1));
      onKeyPress(['enter', 'space'], () => {
        let idx = selected;
        // If nothing selected, try hovered item
        if (idx < 0) {
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            const hovered = typeof it.isHovering === 'function' ? it.isHovering() : (typeof it.isHovered === 'function' ? it.isHovered() : false);
            if (hovered) { idx = i; break; }
          }
        }
        // Fallback to first item
        if (idx < 0) idx = 0;
        go('level', monsters[idx].key);
      });

      // Also allow clicking anywhere near the selected item with Enter hint
      updateSelection();

      // Help text
      const help = add([
        text('Use Arrow Keys + Enter, or Click a Monster', { size: 18 }),
        pos(width() / 2, height() - 32),
        anchor('center'),
        color(40, 40, 40),
      ]);

      function relayoutMenu() {
        // recompute layout metrics
        const paddingX = spriteMax + 100;
        const paddingY = spriteMax + 100;
        const startX = width() / 2 - ((cols - 1) * paddingX) / 2;
        const startY = height() / 2 - paddingY / 2;

        title.pos = vec2(width() / 2, 48);
        char.pos = vec2(width() / 2, rainbowBottomY());
        help.pos = vec2(width() / 2, height() - 32);

        items.forEach((item, i) => {
          const col = i % cols;
          const row = Math.floor(i / cols);
          const x = startX + col * paddingX;
          const y = startY + row * paddingY;
          item.pos = vec2(x, y);
          if (item.menuLabel) {
            item.menuLabel.pos = vec2(x, y + spriteMax / 2 + 24);
          }
        });
      }

      // Register relayout for this scene
      currentRelayout = relayoutMenu;

      // Do an initial relayout in case of early size changes
      relayoutMenu();
    });

    // Level scene
    scene('level', (monsterKey) => {
      const rainbow = document.querySelector('.rainbow-container');
      if (rainbow) rainbow.style.display = 'none';
      buildGrid();

      onKeyPress('escape', () => go('menu'));

      if (monsterKey !== 'red') {
        // Show simple message for non-ready levels
        add([
          sprite(monsterKey),
          anchor('center'),
          pos(width() / 2, height() / 2 - 40),
          scale(2),
        ]);
        add([
          text('Level not ready', { size: 28 }),
          anchor('center'),
          pos(width() / 2, 52),
          color(0, 0, 0),
        ]);
        add([
          text('Press Esc or Click to return', { size: 18 }),
          anchor('center'),
          pos(width() / 2, height() - 32),
          color(40, 40, 40),
        ]);
        onClick(() => go('menu'));
        currentRelayout = () => {};
        return;
      }

      // --- RED LEVEL IMPLEMENTATION ---

      // World metrics
      const WORLD_COLS = 100;
      const WORLD_ROWS = 100;
      const WORLD_W = WORLD_COLS * GRID;
      const WORLD_H = WORLD_ROWS * GRID;

      // Draw a subtle world border (optional)
      const border = add([
        rect(WORLD_W, WORLD_H),
        anchor('topleft'),
        pos(0, 0),
        color(255, 255, 255),
        opacity(0),
        z(-2000),
      ]);

      // Player
      const player = add([
        sprite('char-front'),
        pos(GRID * 2, GRID * 2),
        anchor('center'),
        area(),
        z(10),
        {
          moving: false,
          target: vec2(0, 0),
          dir: 'down',
        },
      ]);
      // Scale player to roughly fit a grid cell
      onUpdate(() => {
        if (!player.__sized) {
          const base = Math.max(player.width, player.height);
          const s = base > 0 ? (GRID * 0.95) / base : 1;
          player.scale = vec2(s);
          player.__sized = true;
        }
      });

      function snapToGrid(v) {
        return vec2(Math.round(v.x / GRID) * GRID, Math.round(v.y / GRID) * GRID);
      }

      function withinWorld(p) {
        return p.x >= GRID * 0.5 && p.y >= GRID * 0.5 && p.x <= WORLD_W - GRID * 0.5 && p.y <= WORLD_H - GRID * 0.5;
      }

      const SPEED = GRID * 6; // pixels per second

      function setDir(dir) {
        if (dir === player.dir) return;
        player.dir = dir;
        if (dir === 'down') player.use(sprite('char-front'));
        if (dir === 'up') player.use(sprite('char-back'));
        if (dir === 'right') { player.use(sprite('char-right')); player.flipX = false; }
        if (dir === 'left')  { player.use(sprite('char-right')); player.flipX = true; }
      }

      function tryStartMove(dir) {
        if (player.moving) return false;
        const cur = snapToGrid(player.pos);
        let next = cur.clone();
        if (dir === 'left') next.x -= GRID;
        if (dir === 'right') next.x += GRID;
        if (dir === 'up') next.y -= GRID;
        if (dir === 'down') next.y += GRID;
        if (!withinWorld(next)) return false;
        player.target = next;
        player.moving = true;
        setDir(dir);
        return true;
      }

      onKeyPress(['left', 'right', 'up', 'down', 'a', 'd', 'w', 's'], (k) => {
        const dir = (k === 'a' || k === 'left') ? 'left'
          : (k === 'd' || k === 'right') ? 'right'
          : (k === 'w' || k === 'up') ? 'up' : 'down';
        tryStartMove(dir);
      });

      // Continuous movement queueing if key held
      onUpdate(() => {
        // Smooth move toward target
        if (player.moving) {
          const delta = player.target.sub(player.pos);
          const dist = delta.len();
          const step = SPEED * dt();
          if (dist <= step) {
            player.pos = player.target.clone();
            player.moving = false;
          } else {
            player.pos = player.pos.add(delta.unit().scale(step));
          }
        } else {
          // Not moving: if a direction is held, start moving to next cell
          let dirHeld = null;
          if (isKeyDown('left') || isKeyDown('a')) dirHeld = 'left';
          else if (isKeyDown('right') || isKeyDown('d')) dirHeld = 'right';
          else if (isKeyDown('up') || isKeyDown('w')) dirHeld = 'up';
          else if (isKeyDown('down') || isKeyDown('s')) dirHeld = 'down';
          if (dirHeld) tryStartMove(dirHeld);
        }

        // Camera scroll with 40% margins
        const marginX = width() * 0.4;
        const marginY = height() * 0.4;
        let cam = camPos();
        const left = cam.x - width() / 2 + marginX;
        const right = cam.x + width() / 2 - marginX;
        const top = cam.y - height() / 2 + marginY;
        const bottom = cam.y + height() / 2 - marginY;
        let cx = cam.x;
        let cy = cam.y;
        if (player.pos.x < left) cx = player.pos.x - (width() / 2 - marginX);
        if (player.pos.x > right) cx = player.pos.x + (width() / 2 - marginX);
        if (player.pos.y < top) cy = player.pos.y - (height() / 2 - marginY);
        if (player.pos.y > bottom) cy = player.pos.y + (height() / 2 - marginY);
        // Clamp camera to world
        cx = Math.max(width() / 2, Math.min(WORLD_W - width() / 2, cx));
        cy = Math.max(height() / 2, Math.min(WORLD_H - height() / 2, cy));
        camPos(cx, cy);
      });

      // Initial camera center near player
      camPos(player.pos);

      // Relayout handler (mostly grid is overlay; keep camera clamped)
      currentRelayout = () => {
        // Keep camera within world bounds on resize
        const cam = camPos();
        const cx = Math.max(width() / 2, Math.min(WORLD_W - width() / 2, cam.x));
        const cy = Math.max(height() / 2, Math.min(WORLD_H - height() / 2, cam.y));
        camPos(cx, cy);
      };
    });

    // Start the game once assets are loaded
    onLoad(() => {
      go('menu');
    });

    // Initial grid build (for first scene before any resize events)
    buildGrid();

    console.log('Kaboom menu initialized');
  </script>
</body>
</html>
