<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kaboom.js Template</title>
  <meta name="description" content="Minimal Kaboom.js template: just a game window in the browser with boilerplate and dependencies via CDN." />
  <style>
    /* Make the canvas fill the whole window */
    html, body {
      height: 100%;
      margin: 0;
      background: #000; /* fallback background while Kaboom initializes */
    }
    #game {
      display: block; /* remove inline gap */
      width: 100vw;
      height: 100vh;
    }
    /* Optional: hide overflow on mobile address bar changes */
    body { overflow: hidden; }
  </style>
</head>
<body>
  <!-- The canvas Kaboom will render to -->
  <canvas id="game"></canvas>

  <!-- Use Kaboom via CDN (ESM). Pin to a stable version to avoid breaking changes. -->
  <script src="https://unpkg.com/kaboom@3000.0.1/dist/kaboom.js"></script>
  <script type="module">
    // Initialize Kaboom. Using global: true exposes helpers like add(), sprite(), pos(), etc.
    const k = kaboom({
      canvas: document.querySelector('#game'),
      width: window.innerWidth,
      height: window.innerHeight,
      background: [ 0, 0, 0 ], // black background
      letterbox: true,
      global: true,
      // Set pixelDensity to 1 to keep a 1:1 mapping of CSS pixels to canvas pixels (optional)
      pixelDensity: 1,
    });

    // Grid overlay: draw a light grid across the canvas and keep it updated on resize
    let gridLines = [];

    function clearGrid() {
      for (const line of gridLines) {
        destroy(line);
      }
      gridLines = [];
    }

    function buildGrid(spacing = 64, lineW = 1, alpha = 0.2) {
      clearGrid();
      const w = width();
      const h = height();

      // Vertical lines
      for (let x = 0; x <= w; x += spacing) {
        const v = add([
          rect(lineW, h),
          anchor('topleft'),
          pos(x, 0),
          opacity(alpha),
          z(-1000),
        ]);
        gridLines.push(v);
      }

      // Horizontal lines
      for (let y = 0; y <= h; y += spacing) {
        const hLine = add([
          rect(w, lineW),
          anchor('topleft'),
          pos(0, y),
          opacity(alpha),
          z(-1000),
        ]);
        gridLines.push(hLine);
      }
    }

    // Keep canvas sized to the window on resize and rebuild the grid
    window.addEventListener('resize', () => {
      k.resize(window.innerWidth, window.innerHeight);
      // Rebuild grid in whatever current scene is active
      buildGrid();
    });

    // Load all monster sprites from img/
    const monsters = [
      { key: 'blue',   path: 'img/blue-monster.png',   label: 'Blue' },
      { key: 'green',  path: 'img/green-monster.png',  label: 'Green' },
      { key: 'orange', path: 'img/orange-monster.png', label: 'Orange' },
      { key: 'purple', path: 'img/purple-monster.png', label: 'Purple' },
      { key: 'red',    path: 'img/red-monster.png',    label: 'Red' },
      { key: 'yellow', path: 'img/yellow-monster.png', label: 'Yellow' },
    ];

    for (const m of monsters) {
      loadSprite(m.key, m.path);
    }

    // Menu scene: shows all monsters; click or use arrows+Enter to select
    scene('menu', () => {
      buildGrid();

      // Title
      add([
        text('Choose a Monster', { size: 32 }),
        pos(width() / 2, 48),
        anchor('center'),
        color(255, 255, 255),
        z(10),
      ]);

      const cols = 3;
      // Target maximum sprite size for uniform appearance (in pixels)
      const spriteMax = 120;
      // Cell padding should be large enough to accommodate enlarged selection (1.2x)
      const paddingX = spriteMax + 100;
      const paddingY = spriteMax + 100;
      const startX = width() / 2 - ((cols - 1) * paddingX) / 2;
      const startY = height() / 2 - paddingY / 2;

      const items = [];

      monsters.forEach((m, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = startX + col * paddingX;
        const y = startY + row * paddingY;

        const item = add([
          sprite(m.key),
          anchor('center'),
          pos(x, y),
          scale(1),
          area({ cursor: 'pointer' }),
          { monsterKey: m.key, monsterLabel: m.label, baseScale: 1 },
        ]);

        // Compute a uniform base scale so the sprite fits within spriteMax box
        const w = item.width;
        const h = item.height;
        const s = Math.min(spriteMax / w, spriteMax / h);
        item.baseScale = s;
        item.scale = vec2(s);

        // Label under sprite, positioned based on spriteMax to keep spacing consistent
        add([
          text(m.label, { size: 18 }),
          anchor('top'),
          pos(x, y + spriteMax / 2 + 24),
          color(255, 255, 255),
        ]);

        item.onClick(() => {
          go('level', m.key);
        });

        items.push(item);
      });

      let selected = 0;

      function updateSelection() {
        items.forEach((it, idx) => {
          const mult = idx === selected ? 1.2 : 1;
          it.scale = vec2(it.baseScale * mult);
          it.opacity = idx === selected ? 1 : 0.9;
        });
      }

      function clampIndex(i) {
        const n = items.length;
        return (i + n) % n;
      }

      function moveHorizontal(dir) {
        selected = clampIndex(selected + dir);
        updateSelection();
      }

      function moveVertical(dir) {
        const n = items.length;
        const cols = 3;
        const rows = Math.ceil(n / cols);
        const curCol = selected % cols;
        const curRow = Math.floor(selected / cols);
        let newRow = curRow + dir;
        if (newRow < 0) newRow = rows - 1;
        if (newRow >= rows) newRow = 0;
        let newIndex = newRow * cols + curCol;
        // If last row is shorter, clamp to last item
        if (newIndex >= n) newIndex = n - 1;
        selected = newIndex;
        updateSelection();
      }

      onKeyPress('left', () => moveHorizontal(-1));
      onKeyPress('right', () => moveHorizontal(1));
      onKeyPress('up', () => moveVertical(-1));
      onKeyPress('down', () => moveVertical(1));
      onKeyPress(['enter', 'space'], () => {
        go('level', monsters[selected].key);
      });

      // Also allow clicking anywhere near the selected item with Enter hint
      updateSelection();

      // Help text
      add([
        text('Use Arrow Keys + Enter, or Click a Monster', { size: 18 }),
        pos(width() / 2, height() - 32),
        anchor('center'),
        color(200, 200, 200),
      ]);
    });

    // Empty level scene for each monster
    scene('level', (monsterKey) => {
      buildGrid();

      // Show the monster centered
      add([
        sprite(monsterKey),
        anchor('center'),
        pos(width() / 2, height() / 2 - 32),
        scale(2),
      ]);

      add([
        text(`Level: ${monsterKey} (empty)`, { size: 24 }),
        anchor('center'),
        pos(width() / 2, 48),
      ]);

      add([
        text('Press Esc to return to Menu', { size: 18 }),
        anchor('center'),
        pos(width() / 2, height() - 32),
        color(200, 200, 200),
      ]);

      onKeyPress('escape', () => go('menu'));
      onClick(() => go('menu'));
    });

    // Start the game once assets are loaded
    onLoad(() => {
      go('menu');
    });

    // Initial grid build (for first scene before any resize events)
    buildGrid();

    console.log('Kaboom menu initialized');
  </script>
</body>
</html>
