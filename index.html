<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kaboom.js Template</title>
  <meta name="description" content="Minimal Kaboom.js template: just a game window in the browser with boilerplate and dependencies via CDN." />
  <style>
    /* Make the canvas fill the whole window */
    html, body {
      height: 100%;
      margin: 0;
      background: #eee; /* light gray fallback background while Kaboom initializes */
    }
    #game {
      display: block; /* remove inline gap */
      width: 100vw;
      height: 100vh;
    }
    /* Optional: hide overflow on mobile address bar changes */
    body { overflow: hidden; }
  </style>
</head>
<body>
  <!-- The canvas Kaboom will render to -->
  <canvas id="game"></canvas>

  <!-- Use Kaboom via CDN (ESM). Pin to a stable version to avoid breaking changes. -->
  <script src="https://unpkg.com/kaboom@3000.0.1/dist/kaboom.js"></script>
  <script type="module">
    // Initialize Kaboom. Using global: true exposes helpers like add(), sprite(), pos(), etc.
    const k = kaboom({
      canvas: document.querySelector('#game'),
      width: window.innerWidth,
      height: window.innerHeight,
      background: [ 230, 230, 230 ], // light gray background
      letterbox: true,
      global: true,
      // Set pixelDensity to 1 to keep a 1:1 mapping of CSS pixels to canvas pixels (optional)
      pixelDensity: 1,
    });

    // A global relayout callback that current scene can register
    let currentRelayout = null;

    // Grid overlay: draw a light grid across the canvas and keep it updated on resize
    let gridLines = [];

    function clearGrid() {
      for (const line of gridLines) {
        destroy(line);
      }
      gridLines = [];
    }

    function buildGrid(spacing = 64, lineW = 1, alpha = 0.6) {
      clearGrid();
      const w = width();
      const h = height();

      // Vertical lines (slightly bluish gray)
      for (let x = 0; x <= w; x += spacing) {
        const v = add([
          rect(lineW, h),
          anchor('topleft'),
          pos(x, 0),
          color(170, 180, 200),
          opacity(alpha),
          z(-1000),
        ]);
        gridLines.push(v);
      }

      // Horizontal lines (slightly reddish gray)
      for (let y = 0; y <= h; y += spacing) {
        const hLine = add([
          rect(w, lineW),
          anchor('topleft'),
          pos(0, y),
          color(200, 180, 180),
          opacity(alpha),
          z(-1000),
        ]);
        gridLines.push(hLine);
      }
    }

    // Keep canvas sized to the window on resize and rebuild the grid
    window.addEventListener('resize', () => {
      // Use global resize helper from Kaboom (k.resize may not exist)
      if (typeof resize === 'function') {
        resize(window.innerWidth, window.innerHeight);
      } else if (k && k.canvas) {
        // Fallback: manually resize the canvas element
        k.canvas.width = window.innerWidth;
        k.canvas.height = window.innerHeight;
      }
      // Rebuild grid in whatever current scene is active
      buildGrid();
      // Ask current scene (if any) to recompute layout/positions
      if (typeof currentRelayout === 'function') {
        currentRelayout();
      }
    });

    // Load all monster sprites from img/
    const monsters = [
      { key: 'blue',   path: 'img/blue-monster.png',   label: 'Blue' },
      { key: 'green',  path: 'img/green-monster.png',  label: 'Green' },
      { key: 'orange', path: 'img/orange-monster.png', label: 'Orange' },
      { key: 'purple', path: 'img/purple-monster.png', label: 'Purple' },
      { key: 'red',    path: 'img/red-monster.png',    label: 'Red' },
      { key: 'yellow', path: 'img/yellow-monster.png', label: 'Yellow' },
    ];

    for (const m of monsters) {
      loadSprite(m.key, m.path);
    }
    // Load player character (front) for decorative menu display
    loadSprite('char-front', 'img/char-front.png');

    // Menu scene: shows all monsters; click or use arrows+Enter to select
    scene('menu', () => {
      buildGrid();

      // Title
      const title = add([
        text('Choose a Monster', { size: 32 }),
        pos(width() / 2, 48),
        anchor('center'),
        color(0, 0, 0),
        z(10),
      ]);

      // Decorative player character (non-interactive) at a small, consistent size
      const char = add([
        sprite('char-front'),
        anchor('center'),
        // Place at the top center in menu
        pos(width() / 2, 110),
        z(5),
        opacity(0.95),
      ]);
      // Fit the character into a target max dimension (in pixels)
      const charTarget = 140; // make the player character larger on main page
      const charBase = Math.max(char.width, char.height);
      const charScale = charBase > 0 ? (charTarget / charBase) : 1;
      char.scale = vec2(charScale);

      const cols = 3;
      // Target maximum sprite size for uniform appearance (in pixels)
      const spriteMax = 150;
      // Cell padding should be large enough to accommodate enlarged selection (1.2x)
      const paddingX = spriteMax + 100;
      const paddingY = spriteMax + 100;
      const startX = width() / 2 - ((cols - 1) * paddingX) / 2;
      const startY = height() / 2 - paddingY / 2;

      const items = []; const labels = [];

      monsters.forEach((m, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = startX + col * paddingX;
        const y = startY + row * paddingY;

        const item = add([
          sprite(m.key),
          anchor('center'),
          pos(x, y),
          scale(1),
          area({ cursor: 'pointer' }),
          { monsterKey: m.key, monsterLabel: m.label, baseScale: 1 },
        ]);

        // Compute a uniform base scale so the sprite fits within spriteMax box
        const w = item.width;
        const h = item.height;
        const sRaw = Math.min(spriteMax / Math.max(1, w), spriteMax / Math.max(1, h));
        // Slightly increase red monster size for better prominence
        const s = m.key === 'red' ? sRaw * 1.1 : sRaw;
        item.baseScale = s;
        item.scale = vec2(s);

        // Label under sprite, positioned based on spriteMax to keep spacing consistent
        const label = add([
          text(m.label, { size: 18 }),
          anchor('top'),
          pos(x, y + spriteMax / 2 + 24),
          color(20, 20, 20),
        ]);
        labels.push(label);
        item.menuLabel = label;

        item.onClick(() => {
          go('level', m.key);
        });

        // Hover visual: slight scale-up and full opacity when hovered
        item.onUpdate(() => {
          const hovered = typeof item.isHovering === 'function' ? item.isHovering() : (typeof item.isHovered === 'function' ? item.isHovered() : false);
          const isSelected = (i === selected);
          let mult = isSelected ? 1.2 : 1;
          if (hovered) mult = Math.max(mult, 1.1);
          item.scale = vec2(item.baseScale * mult);
          item.opacity = (isSelected || hovered) ? 1 : 0.9;
        });

        items.push(item);
      });

      let selected = -1;

      function updateSelection() {
        // Selection visuals handled per-item in onUpdate combining selection and hover states.
        // This function remains to keep keyboard navigation logic intact.
      }

      function clampIndex(i) {
        const n = items.length;
        return (i + n) % n;
      }

      function moveHorizontal(dir) {
        selected = clampIndex(selected + dir);
        updateSelection();
      }

      function moveVertical(dir) {
        const n = items.length;
        const cols = 3;
        const rows = Math.ceil(n / cols);
        const curCol = selected % cols;
        const curRow = Math.floor(selected / cols);
        let newRow = curRow + dir;
        if (newRow < 0) newRow = rows - 1;
        if (newRow >= rows) newRow = 0;
        let newIndex = newRow * cols + curCol;
        // If last row is shorter, clamp to last item
        if (newIndex >= n) newIndex = n - 1;
        selected = newIndex;
        updateSelection();
      }

      onKeyPress('left', () => moveHorizontal(-1));
      onKeyPress('right', () => moveHorizontal(1));
      onKeyPress('up', () => moveVertical(-1));
      onKeyPress('down', () => moveVertical(1));
      onKeyPress(['enter', 'space'], () => {
        let idx = selected;
        // If nothing selected, try hovered item
        if (idx < 0) {
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            const hovered = typeof it.isHovering === 'function' ? it.isHovering() : (typeof it.isHovered === 'function' ? it.isHovered() : false);
            if (hovered) { idx = i; break; }
          }
        }
        // Fallback to first item
        if (idx < 0) idx = 0;
        go('level', monsters[idx].key);
      });

      // Also allow clicking anywhere near the selected item with Enter hint
      updateSelection();

      // Help text
      const help = add([
        text('Use Arrow Keys + Enter, or Click a Monster', { size: 18 }),
        pos(width() / 2, height() - 32),
        anchor('center'),
        color(40, 40, 40),
      ]);

      function relayoutMenu() {
        // recompute layout metrics
        const paddingX = spriteMax + 100;
        const paddingY = spriteMax + 100;
        const startX = width() / 2 - ((cols - 1) * paddingX) / 2;
        const startY = height() / 2 - paddingY / 2;

        title.pos = vec2(width() / 2, 48);
        char.pos = vec2(width() / 2, 110);
        help.pos = vec2(width() / 2, height() - 32);

        items.forEach((item, i) => {
          const col = i % cols;
          const row = Math.floor(i / cols);
          const x = startX + col * paddingX;
          const y = startY + row * paddingY;
          item.pos = vec2(x, y);
          if (item.menuLabel) {
            item.menuLabel.pos = vec2(x, y + spriteMax / 2 + 24);
          }
        });
      }

      // Register relayout for this scene
      currentRelayout = relayoutMenu;

      // Do an initial relayout in case of early size changes
      relayoutMenu();
    });

    // Empty level scene for each monster
    scene('level', (monsterKey) => {
      buildGrid();

      // Show the monster centered
      const centerMonster = add([
        sprite(monsterKey),
        anchor('center'),
        pos(width() / 2, height() / 2 - 32),
        scale(2),
      ]);

      const levelTitle = add([
        text(`Level: ${monsterKey} (empty)`, { size: 24 }),
        anchor('center'),
        pos(width() / 2, 48),
        color(0, 0, 0),
      ]);

      const backHint = add([
        text('Press Esc to return to Menu', { size: 18 }),
        anchor('center'),
        pos(width() / 2, height() - 32),
        color(40, 40, 40),
      ]);

      function relayoutLevel() {
        centerMonster.pos = vec2(width() / 2, height() / 2 - 32);
        levelTitle.pos = vec2(width() / 2, 48);
        backHint.pos = vec2(width() / 2, height() - 32);
      }

      currentRelayout = relayoutLevel;
      relayoutLevel();

      onKeyPress('escape', () => go('menu'));
      onClick(() => go('menu'));
    });

    // Start the game once assets are loaded
    onLoad(() => {
      go('menu');
    });

    // Initial grid build (for first scene before any resize events)
    buildGrid();

    console.log('Kaboom menu initialized');
  </script>
</body>
</html>
